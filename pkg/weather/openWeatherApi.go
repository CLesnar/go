package weather

import (
	"context"
	"encoding/json"
	"fmt"

	"github.com/CLesnar/go/internal/pkg/http"
	"github.com/CLesnar/go/internal/pkg/util"
)

// openweatherapi is one source for getting weather data.

// See OpenWeatherMap details on APIs: https://openweathermap.org/current
// Example of API call to CurrentWeatherData:
// https://api.openweathermap.org/data/2.5/weather?lat=44.34&lon=10.99&appid={API key}

// implements weather interface
type OpenWeatherMap struct {
}

type OpenWeatherMapParametersGetCurrentData struct {
	Latitude  float64 `json:"lat"`             // latitude of location on earth to get weather data for
	Longitude float64 `json:"lon"`             // longitude of location on earth to get weather data for
	ApiId     string  `json:"appid"`           // OpenWeatherMap API ID/Key generated by signing up to use their APIs
	Mode      *string `json:"mode,omitempty"`  // Response format. Possible values are xml and html. If you don't use the mode parameter format is JSON by default.
	Units     *string `json:"units,omitempty"` // Units of measurement. standard, metric and imperial units are available. If you do not use the units parameter, standard units will be applied by default.
	Language  *string `json:"lang,omitempty"`  // You can use this parameter to get the output in your language.
}

type OpenWeatherMaResponseGetCurrentData struct {
	Coordinates struct {
		Longitude float64 `json:"lon"` // Longitude of the location
		Latitude  float64 `json:"lat"` // Latitude of the location
	} `json:"coord"`
	Weather []struct {
		Id          int64  `json:"id"`          // Weather condition id
		Main        string `json:"main"`        // Group of weather parameters (Rain, Snow, Clouds etc.)
		Description string `json:"description"` //  Weather condition within the group. Please find more here. You can get the output in your language.
		Icon        string `json:"icon"`        // Weather icon id
	} `json:"weather"`
	Base string `json:"base"` // Internal parameter
	Main struct {
		Temperature    float64 `json:"temp"`       //  Temperature. Unit Default: Kelvin, Metric: Celsius, Imperial: Fahrenheit
		FeelsLike      float64 `json:"feels_like"` // Temperature. This temperature parameter accounts for the human perception of weather. Unit Default: Kelvin, Metric: Celsius, Imperial: Fahrenheit
		Pressure       float64 `json:"pressure"`   // Atmospheric pressure on the sea level, hPa
		Humidity       float64 `json:"humidity"`   // Humidity, %
		TemperatureMin float64 `json:"temp_min"`   // Minimum temperature at the moment. This is minimal currently observed temperature (within large megalopolises and urban areas). Please find more info here. Unit Default: Kelvin, Metric: Celsius, Imperial: Fahrenheit
		TemperatureMax float64 `json:"temp_max"`   // Maximum temperature at the moment. This is maximal currently observed temperature (within large megalopolises and urban areas). Please find more info here. Unit Default: Kelvin, Metric: Celsius, Imperial: Fahrenheit
		SeaLevel       float64 `json:"sea_level"`  // Atmospheric pressure on the sea level, hPa
		GroundLevel    float64 `json:"grnd_level"` // Atmospheric pressure on the ground level, hPa
	} `json:"main"`
	Visibility float64 `json:"visibility"` // Visibility, meter. The maximum value of the visibility is 10 km
	Wind       struct {
		Speed                float64 `json:"speed"` // Wind speed. Unit Default: meter/sec, Metric: meter/sec, Imperial: miles/hour
		WindDirectionDegrees float64 `json:"deg"`   // Wind direction, degrees (meteorological)
		Gust                 float64 `json:"gust"`  // Wind gust. Unit Default: meter/sec, Metric: meter/sec, Imperial: miles/hour
	} `json:"wind"`
	Clouds struct {
		CloudinessPercent float64 `json:"all"` // Cloudiness, %
	} `json:"clouds"`
	Rain struct {
		Volume1Hour float64 `json:"1h,omitempty"` // (where available) Rain volume for the last 1 hour, mm. Please note that only mm as units of measurement are available for this parameter
		Volume3Hour float64 `json:"3h,omitempty"` // (where available) Rain volume for the last 3 hours, mm. Please note that only mm as units of measurement are available for this parameter
	} `json:"rain,omitempty"`
	Snow struct {
		Volume1Hour float64 `json:"1h,omitempty"` // (where available) Snow volume for the last 1 hour, mm. Please note that only mm as units of measurement are available for this parameter
		Volume3Hour float64 `json:"3h,omitempty"` // (where available)Snow volume for the last 3 hours, mm. Please note that only mm as units of measurement are available for this parameter
	} `json:"snow,omitempty"`
	TimeData float64 `json:"dt"` // Time of data calculation, unix, UTC
	System   struct {
		Type    int64  `json:"type"`    // Internal parameter
		Id      int64  `json:"id"`      // Internal parameter
		Message string `json:"message"` // Internal parameter
		Country string `json:"country"` // Country code (GB, JP etc.)
		Sunrise int64  `json:"sunrise"` // Sunrise time, unix, UTC
		Sunset  int64  `json:"sunset"`  // Sunset time, unix, UTC
	} `json:"sys"`
	TimeZone int64  `json:"timezone"` // Shift in seconds from UTC
	Id       int64  `json:"id"`       // City ID. Please note that built-in geocoder functionality has been deprecated.
	Name     string `json:"name"`     // City name. Please note that built-in geocoder functionality has been deprecated.
	Cod      int64  `json:"cod"`      // Internal parameter
}

func (w *OpenWeatherMap) GetCurrentWeatherData(ctx context.Context, parameters OpenWeatherMapParametersGetCurrentData) (OpenWeatherMaResponseGetCurrentData, error) {
	httpHelper, respData := http.Http{}, OpenWeatherMaResponseGetCurrentData{}
	resp, err := httpHelper.GetRequest(ctx, OpenWeatherMapBaseUrl, nil, parameters, nil)
	if err != nil {
		return respData, err
	}
	if err := json.Unmarshal(resp, &respData); err != nil {
		return respData, err
	}
	return respData, nil
}

func (w *OpenWeatherMap) GetWeatherCondition(ctx context.Context, lat float64, lon float64, apiKey string) (map[string]interface{}, error) {
	parameters := OpenWeatherMapParametersGetCurrentData{ApiId: apiKey, Latitude: lat, Longitude: lon, Units: util.ConstantRef("imperial")}
	weatherConditionMap := map[string]interface{}{}
	data, err := w.GetCurrentWeatherData(ctx, parameters)
	if err != nil {
		return weatherConditionMap, err
	}
	weatherConditionMap["temperature"] = fmt.Sprintf("%v Â°F", data.Main.Temperature)
	weatherConditionMap["temperature_condition"] = temperatureCondition(data.Main.FeelsLike)
	weatherConditionMap["city"] = data.Name
	outsideCondition := ""
	for _, weather := range data.Weather {
		outsideCondition += ", " + weather.Main
	}
	if len(outsideCondition) <= 2 {
		outsideCondition = "Normal"
	} else {
		outsideCondition = outsideCondition[2:] // remove first ", "
	}
	weatherConditionMap["outside_condition"] = outsideCondition
	return weatherConditionMap, nil
}
